<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>웹개발 TDD 입문, Jest의 Matchers 정리 | 갈무리곳</title>
    <meta name="description" content="just blog">
    <meta name="generator" content="VitePress v2.0.0-alpha.12">
    <link rel="preload stylesheet" href="/assets/style.B4_DcqmZ.css" as="style">
    <link rel="preload stylesheet" href="/vp-icons.css" as="style">
    
    <script type="module" src="/assets/app.DFQ7Pylp.js"></script>
    <link rel="modulepreload" href="/assets/chunks/theme.kDWXhGo7.js">
    <link rel="modulepreload" href="/assets/chunks/framework.BuAPHyTs.js">
    <link rel="modulepreload" href="/assets/posts_jest-intro_index.md.CVaFWvJ_.lean.js">
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-L3HEVLWBHH"></script>
    <script type="module" src="https://unpkg.com/@google/model-viewer/dist/model-viewer.min.js"></script>
    <script nomodule src="https://unpkg.com/@google/model-viewer/dist/model-viewer-legacy.js"></script>
    <script id="check-dark-mode">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"auto",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
    <script id="check-mac-os">document.documentElement.classList.toggle("mac",/Mac|iPhone|iPod|iPad/i.test(navigator.platform));</script>
  </head>
  <body>
    <div id="app"><div class="mx-auto my-0"><div class="inline-block float-right clearfix mr-4 md:mr-24"><ul class="list-none flex flex-row p-0 mt-3 xl:flex-col xl:mt-4"><!--[--><li class="shadow-md w-16 block bg-white py-2 px-2 mb-2 ml-2 text-center text-black overflow-hidden rounded"><a class="" href="/posts/">Posts</a></li><li class="shadow-md w-16 block bg-white py-2 px-2 mb-2 ml-2 text-center text-black overflow-hidden rounded"><a class="" href="/">About</a></li><!--]--></ul></div><div class="py-16"><div><div class="a4 relative mx-auto shadow-md bg-white antialiased"><h1 class="text-center">웹개발 TDD 입문, Jest의 Matchers 정리</h1><div class="date">01/23/2021</div><div style="position:relative;"><div><p><figure><img src="/assets/uncle-bob-tdd.BXOhtIvh.png" alt="대청소는 어렵다. &lt;br/&gt; 작은 정리를 계속해야 깨끗한 코드베이스를 유지할 수 있다."><figcaption>대청소는 어렵다. <br> 작은 정리를 계속해야 깨끗한 코드베이스를 유지할 수 있다.</figcaption></figure></p><p>Test-driven Development(TDD)를 항상 하고 싶었다. Clean Code 강의를 듣기 시작하면서, 이 생각이 더 커졌다. 책의 저자이자 강의자인 Uncle Bob이 TDD를 무척이나 강조하기도 하고, TDD의 장점을 논리적이고 매력적으로 설명해주었기 때문이다. 그 중 무엇보다 마음에 들었던 것은 &#39;좋은 테스트가 있으면, 리팩토링에 두려움이 없어진다&#39;는 것이다.</p><p>더 나은 엔지니어가 되기 위해 TDD(Test-driven Development)를 실천해보고자 한다. Javascript 진영에서는 어떤 테스팅 툴이 있는지, 특히 내가 사용하는 Vue.js에서는 어떤 툴이 널리 쓰이는지 조사했다. 영상과 도큐먼트들을 살펴보며 유닛 테스트를 먼저 해보기로 하고 Jest를 선택했다.</p><p><a href="https://vuejs.org/v2/guide/testing.html" target="_blank" rel="noreferrer">Vue.js의 테스팅 가이드</a>와 <a href="https://jestjs.io/docs/en/using-matchers" target="_blank" rel="noreferrer">Jest의 공식 도큐먼트</a>를 크게 참조하며 다음을 가볍게 정리해보았다:</p><ul><li>웹개발에서 사용되는 테스트의 종류</li><li>Jest의 시작인 Matchers의 종류</li></ul><h2 id="웹개발에서-사용되는-테스트의-종류" tabindex="-1">웹개발에서 사용되는 테스트의 종류 <a class="header-anchor" href="#웹개발에서-사용되는-테스트의-종류" aria-label="Permalink to “웹개발에서 사용되는 테스트의 종류”">​</a></h2><p>웹개발에 있어서는 크게 세 가지의 테스트가 있다.</p><table tabindex="0"><thead><tr><th>종류</th><th>역할</th><th>라이브러리/솔루션</th></tr></thead><tbody><tr><td>Unit Testing</td><td>말 그대로 작은 유닛을 대상으로 하는 테스트</td><td>Jest, Mocha ( + Chai)</td></tr><tr><td>Component Testing</td><td>UI 컴포넌트가 의도한 대로 작동하는지를 테스트</td><td>Vue Testing Library (@testing-library/vue)</td></tr><tr><td>End-To-End(E2E) Testing</td><td>인프라와 백엔드를 포함하여 실제로 웹이 배포되었을 때 문제 없는지를 테스트</td><td>Cypress.io, Nightwatch.js, Puppeteer, TestCafe</td></tr></tbody></table><h3 id="유닛-테스팅unit-testing" tabindex="-1">유닛 테스팅<sub>Unit Testing</sub> <a class="header-anchor" href="#유닛-테스팅unit-testing" aria-label="Permalink to “유닛 테스팅Unit Testing”">​</a></h3><p>작은 코드 유닛들을 테스트하는 것을 <em>유닛 테스팅</em>이라고 한다. 함수의 출력값이 예상값과 같은지를 확인하는 Assertion이라고 생각할 수 있다. 함수를 작성하기 전에 어떤 입력에 대해 어떤 출력을 기대하는지를 테스트로 작성하고, 그 테스트를 통과하기 위해 실제 함수를 작성하는 것이 일반적이다.</p><p>프로그래머스와 LeetCode와 같은 알고리즘 문제풀이 사이트를 경험해보았다면, 이미 다른 사람이 작성한 테스트를 통과하기 위해 함수를 작성했다는 점에서 유닛 테스팅을 한 경험이 있는 것이다.</p><p>TDD의 기본기이고, 후에 컴포넌트 테스팅에서도 같은 툴을 이용하기도 하기 때문에 잘 정리해두는 것이 좋을 것 같다.</p><h3 id="컴포넌트-테스팅component-testing" tabindex="-1">컴포넌트 테스팅<sub>Component Testing</sub> <a class="header-anchor" href="#컴포넌트-테스팅component-testing" aria-label="Permalink to “컴포넌트 테스팅Component Testing”">​</a></h3><p>Vue 뿐만 아니라, 많은 프론트엔드 프레임워크들이 UI 구성요소를 하나의 컴포넌트로 다룬다. 컴포넌트가 DOM 엘리먼트로 마운트 됐을 때, 의도한 대로 작동하는지를 테스트하는 것을 <em>컴포넌트 테스팅</em>이라고 한다.</p><p>사용자가 UI와 상호작용할 때, 개발자의 의도대로 UI 컴포넌트가 작동하는지를 확인하는 중요한 단계이다. 실제 제품 사용자 뿐만 아니라 다른 개발자가 해당 컴포넌트를 사용할 때도 동의된 컴포넌트 계약<sub>Component Contract</sub><sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>대로 구현되었는지 확인해야 하기 때문에 특히 더 중요한 테스트인 것 같다.</p><p>후에 컴포넌트 테스팅을 할 때도 VTU(Vue Testing Utility)와 함께 Jest를 흔히들 사용하는 것 같다.</p><h3 id="end-to-end-e2e-testing" tabindex="-1">End-To-End(E2E) Testing <a class="header-anchor" href="#end-to-end-e2e-testing" aria-label="Permalink to “End-To-End(E2E) Testing”">​</a></h3><p>실제로 배포되었을 때 예상치 못한 버그가 생기지는 않는지 확인하는 테스팅이다. 프론트엔드는 항상 백엔드와 긴밀히 협력하기 때문에 프론트엔드의 코드만으로는 실제 필드에서 정상 작동할 수 있는지 알 수 없다. 최대한 실제 서비스 환경과 비슷한 환경에서 점검을 하는 단계라고 생각하면 될 듯하다.</p><h2 id="jest의-시작-matchers" tabindex="-1">Jest의 시작, Matchers <a class="header-anchor" href="#jest의-시작-matchers" aria-label="Permalink to “Jest의 시작, Matchers”">​</a></h2><p>Jest는 보통 함수의 반환값을 인자로 받는 <code>expect</code> 함수를 제공한다. 이 함수는 받은 인자를 토대로 &#39;expectation&#39; 객체를 반환한다. 많은 테스트가 이 객체에 붙어 있는 &#39;matchers&#39;라고 불리는 메소드들을 호출함으로써 작성된다.</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki dark-plus" style="background-color:#1E1E1E;color:#D4D4D4;" tabindex="0" dir="ltr"><code><span class="line"><span style="color:#6A9955;">// 예시</span></span>
<span class="line"><span style="color:#DCDCAA;">test</span><span style="color:#D4D4D4;">(</span><span style="color:#CE9178;">&#39;two plus two is four&#39;</span><span style="color:#D4D4D4;">, () </span><span style="color:#569CD6;">=&gt;</span><span style="color:#D4D4D4;"> {</span></span>
<span class="line"><span style="color:#DCDCAA;">  expect</span><span style="color:#D4D4D4;">(</span><span style="color:#B5CEA8;">2</span><span style="color:#D4D4D4;"> + </span><span style="color:#B5CEA8;">2</span><span style="color:#D4D4D4;">).</span><span style="color:#DCDCAA;">toBe</span><span style="color:#D4D4D4;">(</span><span style="color:#B5CEA8;">4</span><span style="color:#D4D4D4;">);</span></span>
<span class="line"><span style="color:#D4D4D4;">});</span></span></code></pre></div><p>아래는 기본적인 matchers를 정리한 표이다.</p><table tabindex="0"><thead><tr><th>예상값 타입</th><th>함수명</th><th>설명</th><th>요약</th></tr></thead><tbody><tr><td>동일성</td><td><code>.toBe</code></td><td>내부적으로 ECMAScript 2015의 <code>Object.is</code>를 사용한다.</td><td><code>===</code></td></tr><tr><td></td><td><code>.toEqual</code></td><td>재귀적으로 객체를 돌면서 각 value가 같은지 확인한다.</td><td><code>_.isEqual</code></td></tr><tr><td>참거짓</td><td><code>.toBeNull</code></td><td>오직 <code>null</code>과 같은지를 확인한다.</td><td><code>=== null</code></td></tr><tr><td></td><td><code>.toBeUndefined</code></td><td>오직 <code>undefined</code>과 같은지를 확인한다.</td><td><code>=== undefined</code></td></tr><tr><td></td><td><code>.toBeDefined</code></td><td><code>undefined</code>이 아닌지를 확인한다.</td><td><code>!== undefined</code></td></tr><tr><td></td><td><code>.toBeTruthy</code></td><td><code>if</code>문이 참이라고 받아들일 값인지 확인한다</td><td><code>!!</code></td></tr><tr><td></td><td><code>.toBeFalsy</code></td><td><code>if</code>문이 거짓이라고 받아들일 값인지 확인한다</td><td><code>!</code></td></tr><tr><td>숫자</td><td><code>.toBeGreaterThan</code></td><td>함수명 그대로이다.</td><td><code>&gt;</code></td></tr><tr><td></td><td><code>.toBeGreaterThanOrEqual</code></td><td>함수명 그대로이다.</td><td><code>&gt;=</code></td></tr><tr><td></td><td><code>.toBeLessthan</code></td><td>함수명 그대로이다.</td><td><code>&lt;</code></td></tr><tr><td></td><td><code>.toBeLessThanOrEqual</code></td><td>함수명 그대로이다.</td><td><code>&lt;=</code></td></tr><tr><td>문자열</td><td><code>.toMatch</code></td><td>정규표현식을 인자로 받아 매치가 일어나면 참이다.</td><td><code>String.prototype.match(regexp) !== null</code></td></tr><tr><td>배열과 반복 가능한 객체<sub>iterables</sub></td><td><code>.toContain</code></td><td>배열 또는 반복 가능한 객체가 특정 요소를 포함하는지 확인한다.</td><td><code>Array.prototype.includes(result)</code></td></tr><tr><td>예외 발생 여부</td><td><code>.toThrow</code></td><td>함수가 호출될 때 에러를 던지는지 확인한다.</td><td></td></tr></tbody></table><p><code>.toThrow</code>의 경우 다음과 같이 감싸는 함수를 작성해야 테스트가 실패하지 않는다:</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki dark-plus" style="background-color:#1E1E1E;color:#D4D4D4;" tabindex="0" dir="ltr"><code><span class="line"><span style="color:#569CD6;">function</span><span style="color:#DCDCAA;"> compileAndroidCode</span><span style="color:#D4D4D4;">() {</span></span>
<span class="line"><span style="color:#C586C0;">  throw</span><span style="color:#569CD6;"> new</span><span style="color:#DCDCAA;"> Error</span><span style="color:#D4D4D4;">(</span><span style="color:#CE9178;">&#39;you are using the wrong JDK&#39;</span><span style="color:#D4D4D4;">);</span></span>
<span class="line"><span style="color:#D4D4D4;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#DCDCAA;">test</span><span style="color:#D4D4D4;">(</span><span style="color:#CE9178;">&#39;compiling android goes as expected&#39;</span><span style="color:#D4D4D4;">, () </span><span style="color:#569CD6;">=&gt;</span><span style="color:#D4D4D4;"> {</span></span>
<span class="line"><span style="color:#DCDCAA;">  expect</span><span style="color:#D4D4D4;">(() </span><span style="color:#569CD6;">=&gt;</span><span style="color:#DCDCAA;"> compileAndroidCode</span><span style="color:#D4D4D4;">()).</span><span style="color:#DCDCAA;">toThrow</span><span style="color:#D4D4D4;">();</span></span>
<span class="line"><span style="color:#DCDCAA;">  expect</span><span style="color:#D4D4D4;">(() </span><span style="color:#569CD6;">=&gt;</span><span style="color:#DCDCAA;"> compileAndroidCode</span><span style="color:#D4D4D4;">()).</span><span style="color:#DCDCAA;">toThrow</span><span style="color:#D4D4D4;">(</span><span style="color:#9CDCFE;">Error</span><span style="color:#D4D4D4;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A9955;">  // 인자로 에러 메시지나 정규표현식을 넣을 수도 있다.</span></span>
<span class="line"><span style="color:#DCDCAA;">  expect</span><span style="color:#D4D4D4;">(() </span><span style="color:#569CD6;">=&gt;</span><span style="color:#DCDCAA;"> compileAndroidCode</span><span style="color:#D4D4D4;">()).</span><span style="color:#DCDCAA;">toThrow</span><span style="color:#D4D4D4;">(</span><span style="color:#CE9178;">&#39;you are using the wrong JDK&#39;</span><span style="color:#D4D4D4;">);</span></span>
<span class="line"><span style="color:#DCDCAA;">  expect</span><span style="color:#D4D4D4;">(() </span><span style="color:#569CD6;">=&gt;</span><span style="color:#DCDCAA;"> compileAndroidCode</span><span style="color:#D4D4D4;">()).</span><span style="color:#DCDCAA;">toThrow</span><span style="color:#D4D4D4;">(</span><span style="color:#D16969;">/JDK/</span><span style="color:#D4D4D4;">);</span></span>
<span class="line"><span style="color:#D4D4D4;">});</span></span></code></pre></div><h2 id="결론" tabindex="-1">결론 <a class="header-anchor" href="#결론" aria-label="Permalink to “결론”">​</a></h2><p>GUI를 만드는 프론트엔드의 특성상, 서버 개발자와 TDD에 접근하는 방식이 조금 달라야 한다고 한다. 기본이 되는 유닛 테스트와 간단한 Matchers에 우선 익숙해지며 웹개발을 위한 TDD의 세계에 들어가면 좋겠다. 나 스스로 높은 코드 품질을 보장하는 개발자가 되기를 바라고, 같은 목표를 갖는 분들께 조금이라도 도움이 되었기를 바라며 글을 마친다.</p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>컴포넌트 계약은 컴포넌트 개발자와 컴포넌트를 소비하는 개발자 사이에 있는 컴포넌트가 어떻게 행동할지에 관한 약속이다. <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section></div></div></div><div class="a5-landscape mx-auto my-4 shadow-md bg-white"><div id="disqus_thread"></div></div></div></div><link href="https://fonts.googleapis.com/css?family=Nanum+Myeongjo&amp;display=swap" rel="stylesheet"></div></div>
    <script>window.__VP_HASH_MAP__=JSON.parse("{\"drafts_blackboard.md\":\"BC7T6qf4\",\"drafts_buisness.md\":\"beUlALOL\",\"drafts_oauth.md\":\"Lvqp9LZg\",\"drafts_usability-heuristics_index.md\":\"fdcVI9ZQ\",\"drafts_vue-component-test_index.md\":\"CnC8m3_H\",\"drafts_zookeeper.md\":\"YiD78-Rr\",\"index.md\":\"CtPp_QWH\",\"notes_test.md\":\"BfCZeigz\",\"posts_awsmelbourne_index.md\":\"SEI-S9aa\",\"posts_book-a-matter-of-life_index.md\":\"DdYUeLll\",\"posts_dynamic-programming_index.md\":\"B4mZy_ZY\",\"posts_fundamental-principles-of-interaction_index.md\":\"eGDBUcPH\",\"posts_gui-on-container_index.md\":\"BY9Fpwf2\",\"posts_index.md\":\"BOCqctj8\",\"posts_jest-intro_index.md\":\"CVaFWvJ_\",\"posts_linebyline_index.md\":\"BXGS5RHK\",\"posts_loventis-noshow-automation_index.md\":\"Bc948RQ0\",\"posts_modules.md\":\"DPWLtyn-\",\"posts_numbergame-comment-md_index.md\":\"DVxZVbDq\",\"posts_terminal-for-fe_01.md\":\"OCVGrY-r\",\"posts_terminal-for-fe_02.md\":\"BYXxKtsE\",\"posts_translation-lazy-evaluation.md\":\"DQakt3eB\",\"posts_translation-suprise-of-building-ml_index.md\":\"Dm0WPDPA\",\"posts_vagrant_and_ansible_index.md\":\"Bvx5iZmY\",\"posts_vue_directive-is-an-assitent.md\":\"CyCoIiru\",\"readme.md\":\"Dq_64CZM\"}");window.__VP_SITE_DATA__=JSON.parse("{\"lang\":\"en-US\",\"dir\":\"ltr\",\"title\":\"갈무리곳\",\"description\":\"just blog\",\"base\":\"/\",\"head\":[],\"router\":{\"prefetchLinks\":true},\"appearance\":true,\"themeConfig\":{\"nav\":[{\"text\":\"Posts\",\"link\":\"/posts/\"},{\"text\":\"About\",\"link\":\"/\"}]},\"locales\":{},\"scrollOffset\":134,\"cleanUrls\":false,\"additionalConfig\":{}}");</script>
    
  </body>
</html>