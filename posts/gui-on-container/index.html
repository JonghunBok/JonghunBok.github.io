<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>컨테이너에서 돌아가는 애플리케이션의 GUI를 이용하는 법 | 갈무리곳</title>
    <meta name="description" content="just blog">
    <link rel="preload stylesheet" href="/assets/style.b660ba69.css" as="style">
    <link rel="modulepreload" href="/assets/app.70ff419d.js">
    <link rel="modulepreload" href="/assets/posts_gui-on-container_index.md.fdb36c9b.lean.js">
    
    <script id="check-dark-light">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
  </head>
  <body>
    <div id="app"><div class="mx-auto my-0"><div class="inline-block float-right clearfix mr-4 md:mr-24"><ul class="list-none flex flex-row p-0 mt-3 xl:flex-col xl:mt-4"><!--[--><li class="shadow-md w-16 block bg-white py-2 px-2 mb-2 ml-2 text-center text-black overflow-hidden rounded"><a class="" href="/posts/">Posts</a></li><li class="shadow-md w-16 block bg-white py-2 px-2 mb-2 ml-2 text-center text-black overflow-hidden rounded"><a class="" href="/">About</a></li><!--]--></ul></div><div class="py-16"><div><div class="a4 relative mx-auto shadow-md antialiased"><h1 class="text-center">컨테이너에서 돌아가는 애플리케이션의 GUI를 이용하는 법</h1><div class="date"> </div><div style="position:relative;"><div><p>도커 컨테이너에서 실행된 애플리케이션의 화면을 내 모니터에서 볼 수 있을까? 가능하다! 어떤 사람들은 IDE, 웹브라우저, 심지어 윈도우 매니저까지 컨테이너에서 실행하기도 한다.</p><p>흔히 알려진 ssh의 X11 포워딩과 vnc로도 컨테이너 내 애플리케이션의 화면을 볼 수 있지만, 두 방법 모두 좋은 속도를 내진 않는다. ssh는 디스플레이 정보를 암호화해서 전송하고 vnc는 컨테이너에서 렌더링을 한 후에 화면을 전송하기 때문에 일상적으로 사용할 만한 GUI 경험을 제공하지 못한다.</p><p>하지만, 더 간단하고 쾌적하게 컨테이너 속 애플리케이션을 활용할 수도 있다. <strong>윈도우 시스템</strong>과 <strong>디스플레이 서버</strong>를 이해하고 이용해서, 로컬에서 돌아가는 것과 비슷한 속도로 컨테이너화한 프로그램의 GUI를 이용해 보자!</p><h2 id="이론" tabindex="-1">이론 <a class="header-anchor" href="#이론" aria-hidden="true">#</a></h2><p>리눅스 환경에서 가장 쉽게 볼 수 있는 <a href="http://X.Org" target="_blank" rel="noreferrer">X.Org</a> 디스플레이 서버와 X11 윈도우 시스템을 기준으로 설명을 진행한다. 바로 실습으로 넘어가서 기작을 이해할 수 있다면 읽지 않아도 좋다.</p><h3 id="설명하는-용어" tabindex="-1">설명하는 용어 <a class="header-anchor" href="#설명하는-용어" aria-hidden="true">#</a></h3><ul><li>디스플레이 서버 (Display Server)</li><li>윈도윙 시스템 (Windowing System / Window System)</li></ul><h3 id="디스플레이-서버란" tabindex="-1">디스플레이 서버란? <a class="header-anchor" href="#디스플레이-서버란" aria-hidden="true">#</a></h3><p><figure><img src="https://i.imgur.com/tZhNrGP.png" alt="GUI의 기본 구성 (출처: 위키피디아)"><figcaption>GUI의 기본 구성 (출처: 위키피디아)</figcaption></figure></p><p>입출력 장치들 (마우스, 키보드, 모니터) 등은 모두 하드웨어다. 리눅스에서 하드웨어를 직접 제어하는 것은 리눅스 커널 뿐이다. 그렇다고 입출력을 알맞게 처리하기 위해서 모든 응용프로그램이 커널 API를 직접 소비한다면, 매우 비효율적일 것이다. &#39;디스플레이 서버(윈도우 서버)&#39;라는 개념은 이런 난점을 해결해준다.</p><p>디스플레이 서버는 커널과 직접 소통하며 애플리케이션과 운영체제 사이에 입출력 정보 통신을 원활히 하는 프로그램이다. 여타 애플리케이션은 클라이언트로서 하드웨어 입출력 신호를 대신 처리해주는 서비스를 디스플레이 서버로부터 받는다.</p><p>디스플레이 서버도 일종의 서버로, 클라이언트들과 통신 프로토콜을 이용해 정보를 주고 받는다. 이 프로토콜은 네트워크-투명(network transparent)할 수도 있고, 그저 네트워크-가능(network possible)일 수도 있다.</p><p>윈도우 안에 GUI를 제공하는 모든 애플리케이션은 디스플레이 서버의 클라이언트인 셈이다. 디스플레이 서버는 WIMP(Windows, Icons, Menus, Pointer) GUI를 지원하는 <strong>윈도윙 시스템</strong>의 핵심 부품이다.</p><h3 id="x-window-system-x11-x-에-대하여" tabindex="-1">X Window System (X11, X)에 대하여 <a class="header-anchor" href="#x-window-system-x11-x-에-대하여" aria-hidden="true">#</a></h3><p>X11는 프로토콜의 집합일 뿐이다. X11 시스템을 갖는다는 것은 이 프로토콜을 준수하는 소프트웨어의 집합을 유지한다는 의미이다. 보통 X11 시스템인 윈도윙 시스템을 X11 또는 X라 한다.</p><p>X는 유닉스 계열 운영체제에서 쉽게 볼 수 있는 비트맵 디스플레이를 위한 윈도윙 시스템이다. 디스플레이 장치에 윈도우를 만들고 움직이거나, 마우스나 키보드와 같은 입력장치와의 기본적인 상호작용을 지원하는 <em>프레임워크</em>이다. X는 1984년에 MIT에서 시작되었으며, <a href="https://www.x.org/wiki/" target="_blank" rel="noreferrer">X.Org</a>에서 오픈소스 구현을 제공하며 프로젝트를 이끌고 있다.</p><p>X는 네트워크 투명성을 지원한다는 점에서 특별하다. 네트워크 상에 있는 다른 컴퓨터에서 돌아가는 프로그램의 화면도 볼 수 있게 해준다. 그렇기 때문에 우리가 도커 컨테이너에서 돌아가는 프로그램의 화면을 볼 수 있다.</p><h3 id="서버-클라이언트" tabindex="-1">서버-클라이언트 <a class="header-anchor" href="#서버-클라이언트" aria-hidden="true">#</a></h3><p><figure><img src="https://i.imgur.com/uVvgOvD.png" alt="X 시스템 구성도 (이미지 출처: 위키피디아)"><figcaption>X 시스템 구성도 (이미지 출처: 위키피디아)</figcaption></figure></p><p>실제 사용자 앞에 있는 컴퓨터에서 꼭 돌아가야 하는 건 결국 디스플레이 서버다. 다분히 애플리케이션의 관점에서 이루어 용어 선택이라, 처음엔 헷갈릴 수 있다. 애플리케이션이 로컬에서 돌아가든, 네트워크 어딘가에서 돌아가든, 애플리케이션은 디스플레이 서버의 클라이언트이다. 위에서 말했듯, 입출력 자원을 커널을 통해 관리하는 서비스를 디스플레이 서버가 담당하며 클라이언트를 대신 해 사용자의 마우스 클릭을 받고, 커널에 그래픽 렌더링을 요청한다.</p><p>ssh의 X포워딩 기능을 이용하는 것도 같은 원리다. 다만 윈도우즈 운영체제에서는 X포워딩 기능을 이용하기 위해선 Xming을 설치해야 하는데, 그건 기본 윈도우즈에 X서버가 없어서, X 서버의 윈도우용으로 포팅된 버전을 설치하는 것이다. Xming은 &#39;윈도우즈를 위한 X 서버&#39;이다.</p><p>우리는 도커 컨테이너 내에서 돌아가는 X 클라이언트인 프로그램이 호스트에서 실행되고 있는 X 디스플레이 서버에 접속할 수 있게 해주면 되는 것이다.</p><h2 id="실습" tabindex="-1">실습 <a class="header-anchor" href="#실습" aria-hidden="true">#</a></h2><p>결국 우리가 해야 하는 일은,</p><ol><li><p>컨테이너를 실행할 때</p><ul><li>디스플레이 소켓을 마운트하고</li><li>컨테이너 내에 디스플레이 환경 변수를 보내주고</li></ul></li><li><p>컨테이너 실행 후에</p><ul><li><code>xhost</code> 명령어를 이용해 컨테이너 내 애플리케이션이 호스트의 디스플레이 서버에 접속할 수 있게 허가 해준다</li></ul></li><li><p>컨테이너 정지 후에</p><ul><li><code>xhost</code> 명령어를 이용해 종료한 컨테이너를 X 서버 접속 허가 리스트에서 지운다</li></ul></li></ol><div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#FFCB6B;">docker</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">container</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">run</span><span style="color:#A6ACCD;"> \ </span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#FFCB6B;">-v</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">/tmp/.X11-unix/:/tmp/.X11-unix</span><span style="color:#A6ACCD;"> \ </span><span style="color:#C3E88D;">#</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">소켓</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">마운팅</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#FFCB6B;">-e</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">DISPLAY</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;"> \ </span><span style="color:#C3E88D;">#</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">환경</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">변수</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">전달</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#FFCB6B;">--name</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">container_name</span><span style="color:#A6ACCD;"> \</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C3E88D;">image_name</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span></span>
<span class="line"><span style="color:#A6ACCD;">    </span></span>
<span class="line"><span style="color:#FFCB6B;">xhost</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">+local:</span><span style="color:#89DDFF;">`</span><span style="color:#FFCB6B;">docker</span><span style="color:#C3E88D;"> container ls -f name=container_name -q</span><span style="color:#89DDFF;">`</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;"># 또는 xhost +local:host</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;"># 컨테이너 종료 후에</span></span>
<span class="line"><span style="color:#FFCB6B;">xhost</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">-local:</span><span style="color:#89DDFF;">`</span><span style="color:#FFCB6B;">docker</span><span style="color:#C3E88D;"> container ls -f name=container_name -q</span><span style="color:#89DDFF;">`</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;"># 또는 xhost -local:host</span></span>
<span class="line"></span></code></pre></div><p>윈도우즈에서 도커를 이용할 경우에 DISPLAY 환경 변수를 다르게 설정해줘야 한다. 아래를 시도해 볼 것을 권한다.</p><div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;"># 컨테이너 안에서 실행</span></span>
<span class="line"><span style="color:#C792EA;">export</span><span style="color:#A6ACCD;"> DISPLAY</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">`</span><span style="color:#FFCB6B;">cat</span><span style="color:#C3E88D;"> /etc/resolv.conf </span><span style="color:#89DDFF;">|</span><span style="color:#C3E88D;"> </span><span style="color:#FFCB6B;">grep</span><span style="color:#C3E88D;"> nameserver </span><span style="color:#89DDFF;">|</span><span style="color:#C3E88D;"> </span><span style="color:#FFCB6B;">awk</span><span style="color:#C3E88D;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">{print 2}</span><span style="color:#89DDFF;">&#39;`</span><span style="color:#C3E88D;">:</span><span style="color:#F78C6C;">0</span><span style="color:#A6ACCD;"> </span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;"># cat /etc/resolve.conf</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;"># 를 하면 사용하는 네임서버의 목록이 나온다.</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;"># grep</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;"># 으로 nameserver라는 텍스트가 등장하는 줄을 골라내서</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;"># awk</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;"># 로 ip 부분만 가져온 후에 :0을 붙여서 DISPLAY라는 환경변수에 넣어준 것이다.</span></span>
<span class="line"></span></code></pre></div><h2 id="요약" tabindex="-1">요약 <a class="header-anchor" href="#요약" aria-hidden="true">#</a></h2><ul><li>윈도윙 시스템은 기본적인 윈도윙을 제공한다.</li><li>디스플레이 서버는 윈도윙 시스템의 핵심이다.</li><li>클라이언트인 애플리케이션을 내가 GUI를 볼 수 있게 해주는 디스플레이 서버에 접속시켜야 한다.</li><li>컨테이너에 디스플레이 통신에 쓰이는 소켓을 마운트해주고, 호스트에서 권한을 주면 된다.</li></ul><h2 id="덧붙이는-이야기" tabindex="-1">덧붙이는 이야기 <a class="header-anchor" href="#덧붙이는-이야기" aria-hidden="true">#</a></h2><ul><li>이 방법 외에도 다양한 방법이 있다. 더 알고 싶다면 <a href="http://wiki.ros.org/docker/Tutorials/GUI" target="_blank" rel="noreferrer">ROS의 튜토리얼</a>을 추천한다.</li><li><code>Xephyr</code>이라는 툴을 이용하면 virtual display를 만들어 이용할 수 있다고 한다. 아직 구력이 부족해 그 효용을 이해하진 못하겠다...</li><li>Wayland가 X11을 대체하고 주 디스플레이 프로토콜이 될 거라는 이야기가 있지만, 아직까진 X가 대세인 것 같다.</li><li>윈도우에서 도커 컨테이너를 생성할 때, 컨테이너의 네임서버가 호스트를 바라보게 하는 것 같다. 기회가 있을 때 구체적인 기작을 공부해보고 싶다.</li></ul><hr><h3 id="참고-링크" tabindex="-1">참고 링크 <a class="header-anchor" href="#참고-링크" aria-hidden="true">#</a></h3><ul><li><a href="http://wiki.ros.org/docker/Tutorials/GUI" target="_blank" rel="noreferrer">http://wiki.ros.org/docker/Tutorials/GUI</a></li><li><a href="https://en.wikipedia.org/wiki/Display_server" target="_blank" rel="noreferrer">https://en.wikipedia.org/wiki/Display_server</a></li><li><a href="https://en.wikipedia.org/wiki/Windowing_system" target="_blank" rel="noreferrer">https://en.wikipedia.org/wiki/Windowing_system</a></li><li><a href="http://fabiorehm.com/blog/2014/09/11/running-gui-apps-with-docker/" target="_blank" rel="noreferrer">http://fabiorehm.com/blog/2014/09/11/running-gui-apps-with-docker/</a></li><li><a href="https://www.linux.org/threads/display-servers-windowing-systems.10456/" target="_blank" rel="noreferrer">https://www.linux.org/threads/display-servers-windowing-systems.10456/</a></li><li><a href="https://en.wikipedia.org/wiki/Network_transparency" target="_blank" rel="noreferrer">https://en.wikipedia.org/wiki/Network_transparency</a></li></ul></div></div></div><div class="a5-landscape mx-auto my-4 shadow-md"><div id="disqus_thread"></div></div></div></div><link href="https://fonts.googleapis.com/css?family=Nanum+Myeongjo&amp;display=swap" rel="stylesheet"></div></div>
    <script>__VP_HASH_MAP__ = JSON.parse("{\"posts_loventis-noshow-automation_index.md\":\"d65007fc\",\"posts_linebyline_index.md\":\"dcbf9c28\",\"posts_terminal-for-fe_01.md\":\"ec8ad012\",\"posts_awsmelbourne_index.md\":\"72e60703\",\"posts_index.md\":\"3aa16081\",\"posts_modules.md\":\"cd65b4fa\",\"posts_book-a-matter-of-life_index.md\":\"d693787d\",\"posts_gui-on-container_index.md\":\"fdb36c9b\",\"index.md\":\"313ba3ca\",\"posts_fundamental-principles-of-interaction_index.md\":\"76f3fce0\",\"posts_vue_directive-is-an-assitent.md\":\"37b2cda2\",\"posts_translation-suprise-of-building-ml_index.md\":\"6f410f6b\",\"posts_jest-intro_index.md\":\"ea70174e\",\"posts_numbergame-comment-md_index.md\":\"ab0ab312\",\"posts_dynamic-programming_index.md\":\"2b8d4e96\",\"posts_vagrant_and_ansible_index.md\":\"1c4e7586\",\"posts_translation-lazy-evaluation.md\":\"ad986641\",\"posts_terminal-for-fe_02.md\":\"5dadb81d\"}")</script>
    <script type="module" async src="/assets/app.70ff419d.js"></script>
    
  </body>
</html>