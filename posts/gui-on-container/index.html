<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>컨테이너에서 돌아가는 애플리케이션의 GUI를 이용하는 법 | 갈무리곳</title>
    <meta name="description" content="just blog">
    <meta name="generator" content="VitePress v2.0.0-alpha.12">
    <link rel="preload stylesheet" href="/assets/style.B4_DcqmZ.css" as="style">
    <link rel="preload stylesheet" href="/vp-icons.css" as="style">
    
    <script type="module" src="/assets/app.DFQ7Pylp.js"></script>
    <link rel="modulepreload" href="/assets/chunks/theme.kDWXhGo7.js">
    <link rel="modulepreload" href="/assets/chunks/framework.BuAPHyTs.js">
    <link rel="modulepreload" href="/assets/posts_gui-on-container_index.md.BY9Fpwf2.lean.js">
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-L3HEVLWBHH"></script>
    <script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-L3HEVLWBHH");</script>
    <script id="check-dark-mode">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"auto",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
    <script id="check-mac-os">document.documentElement.classList.toggle("mac",/Mac|iPhone|iPod|iPad/i.test(navigator.platform));</script>
  </head>
  <body>
    <div id="app"><div class="mx-auto my-0"><div class="inline-block float-right clearfix mr-4 md:mr-24"><ul class="list-none flex flex-row p-0 mt-3 xl:flex-col xl:mt-4"><!--[--><li class="shadow-md w-16 block bg-white py-2 px-2 mb-2 ml-2 text-center text-black overflow-hidden rounded"><a class="" href="/posts/">Posts</a></li><li class="shadow-md w-16 block bg-white py-2 px-2 mb-2 ml-2 text-center text-black overflow-hidden rounded"><a class="" href="/">About</a></li><!--]--></ul></div><div class="py-16"><div><div class="a4 relative mx-auto shadow-md bg-white antialiased"><h1 class="text-center">컨테이너에서 돌아가는 애플리케이션의 GUI를 이용하는 법</h1><div class="date">03/09/2020</div><div style="position:relative;"><div><p>도커 컨테이너에서 실행된 애플리케이션의 화면을 내 모니터에서 볼 수 있을까? 가능하다! 어떤 사람들은 IDE, 웹브라우저, 심지어 윈도우 매니저까지 컨테이너에서 실행하기도 한다.</p><p>흔히 알려진 ssh의 X11 포워딩과 vnc로도 컨테이너 내 애플리케이션의 화면을 볼 수 있지만, 두 방법 모두 좋은 속도를 내진 않는다. ssh는 디스플레이 정보를 암호화해서 전송하고 vnc는 컨테이너에서 렌더링을 한 후에 화면을 전송하기 때문에 일상적으로 사용할 만한 GUI 경험을 제공하지 못한다.</p><p>하지만, 더 간단하고 쾌적하게 컨테이너 속 애플리케이션을 활용할 수도 있다. <strong>윈도우 시스템</strong>과 <strong>디스플레이 서버</strong>를 이해하고 이용해서, 로컬에서 돌아가는 것과 비슷한 속도로 컨테이너화한 프로그램의 GUI를 이용해 보자!</p><h2 id="이론" tabindex="-1">이론 <a class="header-anchor" href="#이론" aria-label="Permalink to “이론”">​</a></h2><p>리눅스 환경에서 가장 쉽게 볼 수 있는 X.Org 디스플레이 서버와 X11 윈도우 시스템을 기준으로 설명을 진행한다. 바로 실습으로 넘어가서 기작을 이해할 수 있다면 읽지 않아도 좋다.</p><h3 id="설명하는-용어" tabindex="-1">설명하는 용어 <a class="header-anchor" href="#설명하는-용어" aria-label="Permalink to “설명하는 용어”">​</a></h3><ul><li>디스플레이 서버 (Display Server)</li><li>윈도윙 시스템 (Windowing System / Window System)</li></ul><h3 id="디스플레이-서버란" tabindex="-1">디스플레이 서버란? <a class="header-anchor" href="#디스플레이-서버란" aria-label="Permalink to “디스플레이 서버란?”">​</a></h3><p><figure><img src="https://i.imgur.com/tZhNrGP.png" alt="GUI의 기본 구성 (출처: 위키피디아)"><figcaption>GUI의 기본 구성 (출처: 위키피디아)</figcaption></figure></p><p>입출력 장치들 (마우스, 키보드, 모니터) 등은 모두 하드웨어다. 리눅스에서 하드웨어를 직접 제어하는 것은 리눅스 커널 뿐이다. 그렇다고 입출력을 알맞게 처리하기 위해서 모든 응용프로그램이 커널 API를 직접 소비한다면, 매우 비효율적일 것이다. &#39;디스플레이 서버(윈도우 서버)&#39;라는 개념은 이런 난점을 해결해준다.</p><p>디스플레이 서버는 커널과 직접 소통하며 애플리케이션과 운영체제 사이에 입출력 정보 통신을 원활히 하는 프로그램이다. 여타 애플리케이션은 클라이언트로서 하드웨어 입출력 신호를 대신 처리해주는 서비스를 디스플레이 서버로부터 받는다.</p><p>디스플레이 서버도 일종의 서버로, 클라이언트들과 통신 프로토콜을 이용해 정보를 주고 받는다. 이 프로토콜은 네트워크-투명(network transparent)할 수도 있고, 그저 네트워크-가능(network possible)일 수도 있다.</p><p>윈도우 안에 GUI를 제공하는 모든 애플리케이션은 디스플레이 서버의 클라이언트인 셈이다. 디스플레이 서버는 WIMP(Windows, Icons, Menus, Pointer) GUI를 지원하는 <strong>윈도윙 시스템</strong>의 핵심 부품이다.</p><h3 id="x-window-system-x11-x-에-대하여" tabindex="-1">X Window System (X11, X)에 대하여 <a class="header-anchor" href="#x-window-system-x11-x-에-대하여" aria-label="Permalink to “X Window System (X11, X)에 대하여”">​</a></h3><p>X11는 프로토콜의 집합일 뿐이다. X11 시스템을 갖는다는 것은 이 프로토콜을 준수하는 소프트웨어의 집합을 유지한다는 의미이다. 보통 X11 시스템인 윈도윙 시스템을 X11 또는 X라 한다.</p><p>X는 유닉스 계열 운영체제에서 쉽게 볼 수 있는 비트맵 디스플레이를 위한 윈도윙 시스템이다. 디스플레이 장치에 윈도우를 만들고 움직이거나, 마우스나 키보드와 같은 입력장치와의 기본적인 상호작용을 지원하는 <em>프레임워크</em>이다. X는 1984년에 MIT에서 시작되었으며, <a href="https://www.x.org/wiki/" target="_blank" rel="noreferrer">X.Org</a>에서 오픈소스 구현을 제공하며 프로젝트를 이끌고 있다.</p><p>X는 네트워크 투명성을 지원한다는 점에서 특별하다. 네트워크 상에 있는 다른 컴퓨터에서 돌아가는 프로그램의 화면도 볼 수 있게 해준다. 그렇기 때문에 우리가 도커 컨테이너에서 돌아가는 프로그램의 화면을 볼 수 있다.</p><h3 id="서버-클라이언트" tabindex="-1">서버-클라이언트 <a class="header-anchor" href="#서버-클라이언트" aria-label="Permalink to “서버-클라이언트”">​</a></h3><p><figure><img src="https://i.imgur.com/uVvgOvD.png" alt="X 시스템 구성도 (이미지 출처: 위키피디아)"><figcaption>X 시스템 구성도 (이미지 출처: 위키피디아)</figcaption></figure></p><p>실제 사용자 앞에 있는 컴퓨터에서 꼭 돌아가야 하는 건 결국 디스플레이 서버다. 다분히 애플리케이션의 관점에서 이루어 용어 선택이라, 처음엔 헷갈릴 수 있다. 애플리케이션이 로컬에서 돌아가든, 네트워크 어딘가에서 돌아가든, 애플리케이션은 디스플레이 서버의 클라이언트이다. 위에서 말했듯, 입출력 자원을 커널을 통해 관리하는 서비스를 디스플레이 서버가 담당하며 클라이언트를 대신 해 사용자의 마우스 클릭을 받고, 커널에 그래픽 렌더링을 요청한다.</p><p>ssh의 X포워딩 기능을 이용하는 것도 같은 원리다. 다만 윈도우즈 운영체제에서는 X포워딩 기능을 이용하기 위해선 Xming을 설치해야 하는데, 그건 기본 윈도우즈에 X서버가 없어서, X 서버의 윈도우용으로 포팅된 버전을 설치하는 것이다. Xming은 &#39;윈도우즈를 위한 X 서버&#39;이다.</p><p>우리는 도커 컨테이너 내에서 돌아가는 X 클라이언트인 프로그램이 호스트에서 실행되고 있는 X 디스플레이 서버에 접속할 수 있게 해주면 되는 것이다.</p><h2 id="실습" tabindex="-1">실습 <a class="header-anchor" href="#실습" aria-label="Permalink to “실습”">​</a></h2><p>결국 우리가 해야 하는 일은,</p><ol><li><p>컨테이너를 실행할 때</p><ul><li>디스플레이 소켓을 마운트하고</li><li>컨테이너 내에 디스플레이 환경 변수를 보내주고</li></ul></li><li><p>컨테이너 실행 후에</p><ul><li><code>xhost</code> 명령어를 이용해 컨테이너 내 애플리케이션이 호스트의 디스플레이 서버에 접속할 수 있게 허가 해준다</li></ul></li><li><p>컨테이너 정지 후에</p><ul><li><code>xhost</code> 명령어를 이용해 종료한 컨테이너를 X 서버 접속 허가 리스트에서 지운다</li></ul></li></ol><div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki dark-plus" style="background-color:#1E1E1E;color:#D4D4D4;" tabindex="0" dir="ltr"><code><span class="line"><span style="color:#DCDCAA;">docker</span><span style="color:#CE9178;"> container</span><span style="color:#CE9178;"> run</span><span style="color:#D7BA7D;"> \ </span></span>
<span class="line"><span style="color:#DCDCAA;">    -v</span><span style="color:#CE9178;"> /tmp/.X11-unix/:/tmp/.X11-unix</span><span style="color:#D7BA7D;"> \ </span><span style="color:#CE9178;">#</span><span style="color:#CE9178;"> 소켓</span><span style="color:#CE9178;"> 마운팅</span></span>
<span class="line"><span style="color:#DCDCAA;">    -e</span><span style="color:#CE9178;"> &quot;DISPLAY&quot;</span><span style="color:#D7BA7D;"> \ </span><span style="color:#CE9178;">#</span><span style="color:#CE9178;"> 환경</span><span style="color:#CE9178;"> 변수</span><span style="color:#CE9178;"> 전달</span></span>
<span class="line"><span style="color:#DCDCAA;">    --name</span><span style="color:#CE9178;"> container_name</span><span style="color:#D7BA7D;"> \</span></span>
<span class="line"><span style="color:#CE9178;">    image_name</span></span>
<span class="line"><span style="color:#D4D4D4;">    </span></span>
<span class="line"><span style="color:#D4D4D4;">    </span></span>
<span class="line"><span style="color:#DCDCAA;">xhost</span><span style="color:#CE9178;"> +local:`</span><span style="color:#DCDCAA;">docker</span><span style="color:#CE9178;"> container ls </span><span style="color:#569CD6;">-f</span><span style="color:#CE9178;"> name=container_name </span><span style="color:#569CD6;">-q</span><span style="color:#CE9178;">`</span></span>
<span class="line"><span style="color:#6A9955;"># 또는 xhost +local:host</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A9955;"># 컨테이너 종료 후에</span></span>
<span class="line"><span style="color:#DCDCAA;">xhost</span><span style="color:#569CD6;"> -local:</span><span style="color:#CE9178;">`</span><span style="color:#DCDCAA;">docker</span><span style="color:#CE9178;"> container ls </span><span style="color:#569CD6;">-f</span><span style="color:#CE9178;"> name=container_name </span><span style="color:#569CD6;">-q</span><span style="color:#CE9178;">`</span></span>
<span class="line"><span style="color:#6A9955;"># 또는 xhost -local:host</span></span></code></pre></div><p>윈도우즈에서 도커를 이용할 경우에 DISPLAY 환경 변수를 다르게 설정해줘야 한다. 아래를 시도해 볼 것을 권한다.</p><div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki dark-plus" style="background-color:#1E1E1E;color:#D4D4D4;" tabindex="0" dir="ltr"><code><span class="line"><span style="color:#6A9955;"># 컨테이너 안에서 실행</span></span>
<span class="line"><span style="color:#569CD6;">export</span><span style="color:#9CDCFE;"> DISPLAY</span><span style="color:#D4D4D4;">=</span><span style="color:#CE9178;">`</span><span style="color:#DCDCAA;">cat</span><span style="color:#CE9178;"> /etc/resolv.conf </span><span style="color:#D4D4D4;">|</span><span style="color:#DCDCAA;"> grep</span><span style="color:#CE9178;"> nameserver </span><span style="color:#D4D4D4;">|</span><span style="color:#DCDCAA;"> awk</span><span style="color:#CE9178;"> &#39;{print 2}&#39;`</span><span style="color:#DCDCAA;">:0</span><span style="color:#D4D4D4;"> </span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A9955;"># cat /etc/resolve.conf</span></span>
<span class="line"><span style="color:#6A9955;"># 를 하면 사용하는 네임서버의 목록이 나온다.</span></span>
<span class="line"><span style="color:#6A9955;"># grep</span></span>
<span class="line"><span style="color:#6A9955;"># 으로 nameserver라는 텍스트가 등장하는 줄을 골라내서</span></span>
<span class="line"><span style="color:#6A9955;"># awk</span></span>
<span class="line"><span style="color:#6A9955;"># 로 ip 부분만 가져온 후에 :0을 붙여서 DISPLAY라는 환경변수에 넣어준 것이다.</span></span></code></pre></div><h2 id="요약" tabindex="-1">요약 <a class="header-anchor" href="#요약" aria-label="Permalink to “요약”">​</a></h2><ul><li>윈도윙 시스템은 기본적인 윈도윙을 제공한다.</li><li>디스플레이 서버는 윈도윙 시스템의 핵심이다.</li><li>클라이언트인 애플리케이션을 내가 GUI를 볼 수 있게 해주는 디스플레이 서버에 접속시켜야 한다.</li><li>컨테이너에 디스플레이 통신에 쓰이는 소켓을 마운트해주고, 호스트에서 권한을 주면 된다.</li></ul><h2 id="덧붙이는-이야기" tabindex="-1">덧붙이는 이야기 <a class="header-anchor" href="#덧붙이는-이야기" aria-label="Permalink to “덧붙이는 이야기”">​</a></h2><ul><li>이 방법 외에도 다양한 방법이 있다. 더 알고 싶다면 <a href="http://wiki.ros.org/docker/Tutorials/GUI" target="_blank" rel="noreferrer">ROS의 튜토리얼</a>을 추천한다.</li><li><code>Xephyr</code>이라는 툴을 이용하면 virtual display를 만들어 이용할 수 있다고 한다. 아직 구력이 부족해 그 효용을 이해하진 못하겠다...</li><li>Wayland가 X11을 대체하고 주 디스플레이 프로토콜이 될 거라는 이야기가 있지만, 아직까진 X가 대세인 것 같다.</li><li>윈도우에서 도커 컨테이너를 생성할 때, 컨테이너의 네임서버가 호스트를 바라보게 하는 것 같다. 기회가 있을 때 구체적인 기작을 공부해보고 싶다.</li></ul><hr><h3 id="참고-링크" tabindex="-1">참고 링크 <a class="header-anchor" href="#참고-링크" aria-label="Permalink to “참고 링크”">​</a></h3><ul><li><a href="http://wiki.ros.org/docker/Tutorials/GUI" target="_blank" rel="noreferrer">http://wiki.ros.org/docker/Tutorials/GUI</a></li><li><a href="https://en.wikipedia.org/wiki/Display_server" target="_blank" rel="noreferrer">https://en.wikipedia.org/wiki/Display_server</a></li><li><a href="https://en.wikipedia.org/wiki/Windowing_system" target="_blank" rel="noreferrer">https://en.wikipedia.org/wiki/Windowing_system</a></li><li><a href="http://fabiorehm.com/blog/2014/09/11/running-gui-apps-with-docker/" target="_blank" rel="noreferrer">http://fabiorehm.com/blog/2014/09/11/running-gui-apps-with-docker/</a></li><li><a href="https://www.linux.org/threads/display-servers-windowing-systems.10456/" target="_blank" rel="noreferrer">https://www.linux.org/threads/display-servers-windowing-systems.10456/</a></li><li><a href="https://en.wikipedia.org/wiki/Network_transparency" target="_blank" rel="noreferrer">https://en.wikipedia.org/wiki/Network_transparency</a></li></ul></div></div></div><div class="a5-landscape mx-auto my-4 shadow-md bg-white"><div id="disqus_thread"></div></div></div></div><link href="https://fonts.googleapis.com/css?family=Nanum+Myeongjo&amp;display=swap" rel="stylesheet"></div></div>
    <script>window.__VP_HASH_MAP__=JSON.parse("{\"drafts_blackboard.md\":\"BC7T6qf4\",\"drafts_buisness.md\":\"beUlALOL\",\"drafts_oauth.md\":\"Lvqp9LZg\",\"drafts_usability-heuristics_index.md\":\"fdcVI9ZQ\",\"drafts_vue-component-test_index.md\":\"CnC8m3_H\",\"drafts_zookeeper.md\":\"YiD78-Rr\",\"index.md\":\"CtPp_QWH\",\"notes_test.md\":\"BfCZeigz\",\"posts_awsmelbourne_index.md\":\"SEI-S9aa\",\"posts_book-a-matter-of-life_index.md\":\"DdYUeLll\",\"posts_dynamic-programming_index.md\":\"B4mZy_ZY\",\"posts_fundamental-principles-of-interaction_index.md\":\"eGDBUcPH\",\"posts_gui-on-container_index.md\":\"BY9Fpwf2\",\"posts_index.md\":\"BOCqctj8\",\"posts_jest-intro_index.md\":\"CVaFWvJ_\",\"posts_linebyline_index.md\":\"BXGS5RHK\",\"posts_loventis-noshow-automation_index.md\":\"Bc948RQ0\",\"posts_modules.md\":\"DPWLtyn-\",\"posts_numbergame-comment-md_index.md\":\"DVxZVbDq\",\"posts_terminal-for-fe_01.md\":\"OCVGrY-r\",\"posts_terminal-for-fe_02.md\":\"BYXxKtsE\",\"posts_translation-lazy-evaluation.md\":\"DQakt3eB\",\"posts_translation-suprise-of-building-ml_index.md\":\"Dm0WPDPA\",\"posts_vagrant_and_ansible_index.md\":\"Bvx5iZmY\",\"posts_vue_directive-is-an-assitent.md\":\"CyCoIiru\",\"readme.md\":\"Dq_64CZM\"}");window.__VP_SITE_DATA__=JSON.parse("{\"lang\":\"en-US\",\"dir\":\"ltr\",\"title\":\"갈무리곳\",\"description\":\"just blog\",\"base\":\"/\",\"head\":[],\"router\":{\"prefetchLinks\":true},\"appearance\":true,\"themeConfig\":{\"nav\":[{\"text\":\"Posts\",\"link\":\"/posts/\"},{\"text\":\"About\",\"link\":\"/\"}]},\"locales\":{},\"scrollOffset\":134,\"cleanUrls\":false,\"additionalConfig\":{}}");</script>
    
  </body>
</html>