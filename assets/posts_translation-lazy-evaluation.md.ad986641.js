import{_ as e,c as a,o as t,a as s}from"./app.70ff419d.js";const h=JSON.parse('{"title":"번역; 게으른 계산이란?","description":"","frontmatter":{"title":"번역; 게으른 계산이란?","tags":["translation","wikipedia","lazy evaluation"],"categories":["translation"],"date":"2018-06-05T11:56:23.000Z","intro":["블로그 글을 읽을 때 계산을 게으르게 한다는 표현이 심심치않게 보인다.","그 표현에 대한 개념을 잡기 위해 영문 위키피디아의 개요를 번역해보았다.","내용 이해에 불필요한 부분은 과감히 생략하였다."],"refs":null},"headers":[{"level":3,"title":"소감","slug":"소감","link":"#소감","children":[]},{"level":3,"title":"번역","slug":"번역","link":"#번역","children":[]}],"relativePath":"posts/translation-lazy-evaluation.md"}'),o={name:"posts/translation-lazy-evaluation.md"},n=s('<h3 id="소감" tabindex="-1">소감 <a class="header-anchor" href="#소감" aria-hidden="true">#</a></h3><p>앞으로 &quot;a는 게으르게 계산된다&quot;라는 표현을 보면, &#39;a가 당장 계산되진 않고 필요할 때 계산되겠구나~&#39; 정도로 생각하면 될 것 같다. 값이 필요할 때 지연 없이 값을 얻어야 하는 작업에서 이 계산전략을 채택하면 안 될 것 같다. (어떤 필드에서 이런 일이 있을까?)</p><h3 id="번역" tabindex="-1">번역 <a class="header-anchor" href="#번역" aria-hidden="true">#</a></h3><p>프로그래밍 언어에서 <em><a href="https://en.wikipedia.org/wiki/Lazy_evaluation" target="_blank" rel="noreferrer">게으른 계산</a></em>, 또는 <em>필요에 따른 호출</em>은 계산 전략의 일종이다. 게으른 계산 전략에선 결과값이 필요할 때까지 표현식의 <strong>계산을 미루고</strong>, <strong>반복된 계산을 피한다</strong>. <em>이름에 따른 호출</em>같은 다른 계산 전략과 비교할 때, <em>공유</em>는 특정 함수들의 실행 시간을 지수함수단위로 줄일 수 있다.</p><p>게으른 계산의 이점들은 다음을 포함한다.</p><ul><li>제어흐름<sub>control</sub> <sub>flow</sub>을 원시값이 아니라 추상으로서 정의할 수 있음.</li><li>잠재적으로 무한한 자료구조를 정의할 수 있음.</li><li>특정 알고리즘들을 더 간명하게 표현할 수 있음.</li><li>불필요한 계산과 복잡한 표현식을 계산할 때 생기는 오류 상황을 피함으로써 능률이 높아짐.</li></ul><p>게으른 계산은 종종 메모이제이션<sub>memoization</sub><sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>과 함께 쓰인다. 인수에 대해 함수의 값이 계산되면, 그 결과는 인수가 인덱스인 룩업<sub>lookup</sub>표에 저장된다. 그 후에 함수가 호출되면, 주어진 인수에 해당하는 값이 이미 룩업표에 있는지 확인한다. 이미 있다면 저장된 값을 반환하고, 없다면 표에 인수를 인덱스로 그 함수값을 저장한다. 게으른 계산에서는 값들이 필요할 떄 만들어지기 때문에, 메모리 풋프린트<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>가 줄기도 한다. 하지만 예외처리나 입출력과 같이 반드시해야 하는 기능들<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>과 함께 사용하기는 어렵다. 왜냐하면 연산의 순서가 비결정적이기 때문이다. 그리고 게으른 계산은 메모리 누수를 부를 수 있다. 게으른 계산의 반대는 <em>엄격한 계산</em><sub>strict</sub> <sub>evaluation</sub>으로도 알려진 <em>조급한 계산</em><sub>eager</sub> <sub>evaluation</sub>이다. 조급한 계산은 대부분의 프로그래밍 언어가 채택하는 계산 전략이다.</p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>비싼 계산에 대한 값을 캐싱하는 최적화 기법 <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p>러닝 타임동안 프로그램이 사용하는 메모리량 <a href="#fnref2" class="footnote-backref">↩︎</a></p></li><li id="fn3" class="footnote-item"><p>imperative features <a href="#fnref3" class="footnote-backref">↩︎</a></p></li></ol></section>',9),i=[n];function l(r,f,c,u,p,d){return t(),a("div",null,i)}const m=e(o,[["render",l]]);export{h as __pageData,m as default};
