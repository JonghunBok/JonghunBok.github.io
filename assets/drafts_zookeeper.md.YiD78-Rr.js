import{_ as a,c as t,o as l,G as r}from"./chunks/framework.BuAPHyTs.js";const u=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"drafts/zookeeper.md","filePath":"drafts/zookeeper.md"}'),i={name:"drafts/zookeeper.md"};function o(s,e,n,p,d,h){return l(),t("div",null,[...e[0]||(e[0]=[r('<ul><li><a href="https://www.youtube.com/watch?v=Vv4HpLfqAz4" target="_blank" rel="noreferrer">https://www.youtube.com/watch?v=Vv4HpLfqAz4</a></li></ul><p>more reliable</p><p>why zookeeper?</p><ul><li>(not paxos)</li><li>battle tested <ul><li>kafka</li><li>solar</li><li>apache</li></ul></li><li><a href="https://jepsen.io/" target="_blank" rel="noreferrer">https://jepsen.io/</a></li></ul><p>Clever Cloud is using zookeeper for</p><ul><li>orchestration</li><li>log drains</li></ul><p>Zookeeper 101</p><ul><li><p>a databse</p></li><li><p>tree-based data</p><ul><li>looks like a file system</li></ul></li><li><p>one element is called a znode</p></li><li><p>znode</p><ul><li>persistent</li><li>ephemeral <ul><li>tied to the session where they were created</li><li><strong>어떤 식으로든 접속이 끊어지면</strong>, 설정된 시간 후에 <strong>znode가 삭제된다</strong>.</li></ul></li><li>sequential <ul><li>A znode suffixed with a sequentially generated integer</li></ul></li></ul></li><li><p>zookeeper guarantees</p><ul><li>sequential consistency</li><li>atomicity <ul><li>completely succeeds or completely fails</li></ul></li><li>single system image</li><li>reliability</li><li>timeliness</li></ul></li><li><p>The API</p><ul><li>Create</li><li>Delete</li><li>Exists</li><li>Get data</li><li>Set data</li><li>Get children</li></ul></li></ul><h2 id="watch" tabindex="-1">watch... <a class="header-anchor" href="#watch" aria-label="Permalink to “watch...”">​</a></h2><p><a href="https://zookeeper.apache.org/doc/current/zookeeperOver.html" target="_blank" rel="noreferrer">https://zookeeper.apache.org/doc/current/zookeeperOver.html</a></p><p>분산 어플리케이션을 위한 coordination 서비스</p><p>Java로 쓰여짐</p><h2 id="design-goals" tabindex="-1">Design Goals <a class="header-anchor" href="#design-goals" aria-label="Permalink to “Design Goals”">​</a></h2><h3 id="주키퍼는-심플하다-로우-레벨-동기화-스타터팩-같은-느낌" tabindex="-1">주키퍼는 심플하다 (로우 레벨? 동기화 스타터팩 같은 느낌) <a class="header-anchor" href="#주키퍼는-심플하다-로우-레벨-동기화-스타터팩-같은-느낌" aria-label="Permalink to “주키퍼는 심플하다 (로우 레벨? 동기화 스타터팩 같은 느낌)”">​</a></h3><p>coordination은 race condition이나 deadlock 등을 처리하는 게 까다로움 주키퍼가 만들어진 이유는 분산 시스템을 만들 때 이런 coordination 서비스를 처음부터 만들지 않아도 되게 하는 데 있음.</p><p>ZooKeeper data is kept in-memory, -&gt; 높은 쓰루풋, 낮은 레이턴시</p><p>주키퍼 구현이 신경쓰는 부분:</p><ul><li>high perfomance -&gt; 대규모 분산 시스템에서 사용할 수 있음</li><li>high availaibility -&gt; spof가 되지 않음</li><li>strictly ordered access -&gt; 정교한 동기화 primitives가 클라이언트 단에서 구현될 수 있음.</li></ul><h3 id="주키퍼는replicated" tabindex="-1">주키퍼는replicated <a class="header-anchor" href="#주키퍼는replicated" aria-label="Permalink to “주키퍼는replicated”">​</a></h3><p>앙상블(ensemble)로 불리는 호스트 집단에 걸쳐 레플리케이트 되어 있당</p><ul><li>주키퍼 서비스를 이루는 서버들은 서로를 모두 알아야 함 <ul><li>in-memory image of state + transaction logs, snapshots in a persistent store &lt;- 서버 대부분이 살아 있으면, 주키퍼도 가용 상태</li></ul></li></ul><h3 id="주키퍼는-ordered" tabindex="-1">주키퍼는 ordered <a class="header-anchor" href="#주키퍼는-ordered" aria-label="Permalink to “주키퍼는 ordered”">​</a></h3><h3 id="주키퍼는-fast" tabindex="-1">주키퍼는 fast <a class="header-anchor" href="#주키퍼는-fast" aria-label="Permalink to “주키퍼는 fast”">​</a></h3><ul><li>특히 read가 많은 환경에서 빠르다. (10:1 정도가 베스트)</li></ul><hr><p>ZAB</p><p>ZAB (ZooKeeper Atomic Broadcast) is a protocol used by ZooKeeper, a distributed coordination service, for achieving high availability and consistency in distributed systems.</p><p>ZAB is a primary-backup protocol that ensures that a single replica, called the leader, receives all updates and then broadcasts them to all other replicas, called followers, in a sequential and consistent manner. The leader manages the ordering of updates and ensures that all followers have received all updates in the same order. This enables the replicas to maintain consistent state and to handle client requests even if some of the replicas fail or are unavailable.</p><p>The ZAB protocol is based on the concept of transaction logs, where each update is represented as a transaction and is appended to the transaction log in a sequential order. The transaction log is maintained by the leader and is replicated to all followers. When a follower requests an update from the leader, the leader sends all transactions that the follower does not have, in the order they were added to the log. Once the follower has received all updates, it acknowledges the leader, and the leader moves on to the next update.</p><p>If the leader fails or becomes unavailable, a new leader is elected by the remaining replicas using a leader election algorithm. The new leader reads the transaction log to ensure that it has all the updates and then starts broadcasting them to the followers. This ensures that the new leader has a consistent view of the namespace.</p><p>In summary, ZAB protocol provides reliable and consistent replication of updates in distributed systems by ensuring that all replicas have the same view of the transaction log and that updates are applied in the same order.</p><hr><p>to read:</p><ul><li><a href="https://aphyr.com/posts/291-call-me-maybe-zookeeper" target="_blank" rel="noreferrer">https://aphyr.com/posts/291-call-me-maybe-zookeeper</a></li><li><a href="https://technologyconversations.com/2015/09/08/service-discovery-zookeeper-vs-etcd-vs-consul/" target="_blank" rel="noreferrer">https://technologyconversations.com/2015/09/08/service-discovery-zookeeper-vs-etcd-vs-consul/</a></li><li><a href="https://zookeeper.apache.org/doc/current/zookeeperOver.html" target="_blank" rel="noreferrer">https://zookeeper.apache.org/doc/current/zookeeperOver.html</a></li></ul><p>to watch: <a href="https://www.youtube.com/@6.824/videos" target="_blank" rel="noreferrer">https://www.youtube.com/@6.824/videos</a> MIT의 분산 시스템 강의</p>',35)])])}const m=a(i,[["render",o]]);export{u as __pageData,m as default};
