import{_ as e,c as s,o,a}from"./app.70ff419d.js";const f=JSON.parse('{"title":"CommonJS 모듈과 package.json","description":"","frontmatter":{"title":"CommonJS 모듈과 package.json","date":"2019-06-05T02:26:58.435Z"},"headers":[{"level":2,"title":"CommonJS","slug":"commonjs","link":"#commonjs","children":[{"level":3,"title":"어떤 것이 모듈로 취급되는가","slug":"어떤-것이-모듈로-취급되는가","link":"#어떤-것이-모듈로-취급되는가","children":[]},{"level":3,"title":"모듈 래퍼module wrapper","slug":"모듈-래퍼module-wrapper","link":"#모듈-래퍼module-wrapper","children":[]},{"level":3,"title":"Core Modules","slug":"core-modules","link":"#core-modules","children":[]}]},{"level":2,"title":"package.json","slug":"package-json","link":"#package-json","children":[]},{"level":2,"title":"얻은 것들rule of thumbs","slug":"얻은-것들rule-of-thumbs","link":"#얻은-것들rule-of-thumbs","children":[]},{"level":2,"title":"참조","slug":"참조","link":"#참조","children":[]}],"relativePath":"posts/modules.md"}'),t={name:"posts/modules.md"},l=a(`<p>모듈에 대해 정확히 이해해야 프로젝트를 하는데 용이할 것 같아 기본적인 내용을 공부하며 정리하고자 한다. Javascript 언어 자체에서 모듈을 지원하기 시작한 것은 ECMAScript 6가 처음이다. ECMAScript 5까지는 모듈 기능을 구현한 라이브러리를 이용해왔다. 이 라이브러리들을 나름의 스탠다드를 구현하고 있는데, 개중에 중요한 2개는 Node.js의 코어모듈로 구현돼있는 CommonJS와 Require.js로 구현돼있는 AMD라고 한다.</p><table><thead><tr><th>스탠다드</th><th>키워드</th></tr></thead><tbody><tr><td>CommonJS</td><td><code>require()</code>, <code>module.exports</code></td></tr><tr><td>AMD <sub>Async Module Definition</sub></td><td><code>require()</code>, <code>define()</code></td></tr><tr><td>UMD <sub>Univeral Module Definition</sub></td><td>즉시실행함수와 <code>this</code> 활용</td></tr><tr><td>ES6</td><td><code>import</code>, <code>export</code></td></tr></tbody><caption id="js_module_standard_types">JS 모듈 스탠다드 종류</caption></table><br><p>ECMA6의 모듈 스펙은 노드에서는 8.5.0버전에서부터 일찍이 구현되어있지만, IE와 Samsung Internet 에서는 지원하지 않고 있다.<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup> 나는 NPM과 Node에 익숙해지고 싶은 것이니, 우선은 CommonJS 위주로 정리를 했다. 거기에 package.json에 대해서도 간단히 조사했다.</p><h2 id="commonjs" tabindex="-1">CommonJS <a class="header-anchor" href="#commonjs" aria-hidden="true">#</a></h2><p>Node.js 공식 API 레퍼런스 문서에서 Modules란에 가면 CommonJS 모듈에 대한 설명이 나온다. Node.js 에서 자체적으로 CommonJS 스탠다드를 구현해 코어 모듈로 사용해왔기 때문이다. 깃허브에서 보면 다음과 같다. 깃헙 레파지토리에서 module 코어 모듈을 들춰보면 다음과 같다.</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// node/lib/module.js</span></span>
<span class="line"><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">use strict</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">module.exports</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">require</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">internal/modules/cjs/loader</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">Module</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span></code></pre></div><p><code>internal/modules/</code>에 가면 CommonJS를 뜻하는 cjs말고도 ECMAScript Module을 구현한 esm도 있다. 아직 cjs를 기본 로더로 사용하고 있는 모습이 인상적이다.</p><h3 id="어떤-것이-모듈로-취급되는가" tabindex="-1">어떤 것이 모듈로 취급되는가 <a class="header-anchor" href="#어떤-것이-모듈로-취급되는가" aria-hidden="true">#</a></h3><p>각 파일은 하나의 모듈로 취급된다. 이는 ECMAScript 모듈에서도 변하지 않는다. 모듈의 크기가 커지면 폴더를 만들어 모듈을 구성하게 되는데, 폴더를 require의 인자로 넘기는 방법은 3가지가 있다.</p><ol><li><p>최상위 폴더의 <code>package.json</code>에 <code>main</code> 프로퍼티를 명시한다. <br> Node에게 엔트리 포인트를 알려주는 것이다.</p></li><li><p>폴더 안에 <code>index.js</code>파일을 포함시키는 것. <br> 만약 <code>package.json</code>에 <code>main</code>값이 없다면 Node.js는 <code>index.js</code> 또는 <code>index.node</code>파일을 찾으려고 한다.</p></li><li><p>2번과 똑같이 <code>index.node</code>를 포함시키는 것.</p></li></ol><h3 id="모듈-래퍼module-wrapper" tabindex="-1">모듈 래퍼<sub>module wrapper</sub> <a class="header-anchor" href="#모듈-래퍼module-wrapper" aria-hidden="true">#</a></h3><p>Node.js는 모듈 안에 있는 코드를 실행하기 전에 아래와 같은 래퍼<sub>wrapper</sub>를 만들어 감싼다고 한다.</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">(</span><span style="color:#C792EA;">function</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">exports</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">require</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">module</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">__filename</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">__dirname</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// Module code actually lives in here</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"></span></code></pre></div><p>이럼으로써 모듈에 정의된 전역변수들이 호출되어온 곳의 메모리 공간을 더럽히지 않게 된다. 그리고 모듈에 로컬한 변수들은 프라이빗 변수가 된다.</p><h3 id="core-modules" tabindex="-1">Core Modules <a class="header-anchor" href="#core-modules" aria-hidden="true">#</a></h3><p>Node.js는 바이너리로 컴파일된 핵심 모듈들을 가진다. Node.js소스 안에 lib/ 폴더 안에 정의돼 있으며 (바이너리로 컴파일 된 버전은 다른 폴더에 있는 듯하다) <code>require</code> 함수에 다른 모듈보다 선호되기 때문에 같은 이름을 가진 모듈이 있다고 해도 핵심 모듈이 로드 된다. lib 폴더에 들어가보면 다음의 파일들을 볼 수 있다.</p><details><summary>lib 폴더 보기</summary><p> - assert.js - async\\_hooks.js - buffer.js - child\\_process.js - cluster.js - console.js - constants.js - crypto.js - dgram.js - dns.js - domain.js - events.js - **fs.js** - **http.js** - http2.js - https.js - inspector.js - module.js - net.js - **os.js** - **path.js** - perf\\_hooks.js - process.js - punycode.js - **querystring.js** - readline.js - repls.js - stream.js - stirng\\_decoder.js - sys.js - timers.js - tls.js - trace\\_events.js - tty.js - **url.js** - **util.js** - v8.js - vm.js - woker\\_threads.js - zlib.js </p></details><h2 id="package-json" tabindex="-1">package.json <a class="header-anchor" href="#package-json" aria-hidden="true">#</a></h2><p>NPM 패키지를 소비하든 제작하든 package.json 문해력은 패키지의 메타정보에 쉽게 접근할 수 있게 해준다. NPM 공식 문서에서 기본적인 정보를 추려 정리했다.</p><p>패키지를 후에 배포할 거라면, <code>name</code> 과 <code>version</code> 필드가 요구된다. <code>version</code>필드는 Semantic Versioning 2.0.0을 따라 작성하면 된다.</p><blockquote><p><strong>Semantic Versioning 2.0.0</strong>에 따르면 MAJOR.MINOR.PATCH의 형식을 따르고, MAJOR는 양립할 수 없는 API의 변화가 따를 때, MINOR는 구버전과 양립할 수 있는 기능이 추가될 때, PATCH는 구버전과 양립할 수 있는 버그 픽스를 할 때 증가한다.</p></blockquote><p><code>files</code>는 <code>.gitigonre</code>와 비슷하지만 반대이다. 깃이그노어가 블랙리스트라면, <code>files</code>필드의 배열은 화이트리스트이다. 기본값은 모든 파일을 포함시키는 <code>[&quot;*&quot;]</code>. <code>.npmignore</code> 파일도 있고, <code>.gitigonre</code>와 똑같이 작용한다. 없으면 깃이그노어가 npm이그노어를 대신한다.</p><p><code>bin</code>에 실행파일을 놓으면 <code>usr/local/bin/</code>아래 심볼링링크가 생긴다. <code>http-server</code>와 같은 bash에서 바로 쓸 수 있는 NPM 패키지들을 보면 이 항목을 활용하는 것을 볼 수 있다.<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup></p><h2 id="얻은-것들rule-of-thumbs" tabindex="-1">얻은 것들<sub>rule of thumbs</sub> <a class="header-anchor" href="#얻은-것들rule-of-thumbs" aria-hidden="true">#</a></h2><p>조사하며 얻은 실용적인 교훈은 다음과 같다.</p><ul><li>코어 모듈은 리콰이어에서 높은 우선순위를 갖는다.</li><li><code>require</code>함수는 주어진 모듈 identifier를 상위폴더로 가며 가장 먼저 찾은 node_modules폴더 안에서 찾는다.</li><li><code>package.json</code>의 <code>main</code> 프로퍼티를 활용해 코어 결과물을 배포하면 되겠다.</li><li>트리쉐이킹<sub>tree shaking</sub>은 정적 구조의 모듈을 갖는 esm부터 가능하구나.</li></ul><h2 id="참조" tabindex="-1">참조 <a class="header-anchor" href="#참조" aria-hidden="true">#</a></h2><ul><li><a href="http://exploringjs.com/es6/ch_modules.html#static-module-structure" target="_blank" rel="noreferrer">ExploringJS.com: Modules</a></li><li><a href="https://www.freecodecamp.org/news/anatomy-of-js-module-systems-and-building-libraries-fadcd8dbd0e/" target="_blank" rel="noreferrer">freeCodeCamp: Learn the basics of the JavaScript module system and build your own library</a></li><li><a href="https://nodejs.org/api/modules.html" target="_blank" rel="noreferrer">Node Official Documents</a></li><li><a href="https://github.com/nodejs/node/tree/master/" target="_blank" rel="noreferrer">Node github repository</a></li><li><a href="http://fredkschott.com/post/2014/06/require-and-the-module-system/" target="_blank" rel="noreferrer">require and the module system</a></li><li><a href="https://docs.npmjs.com/files/package.json.html" target="_blank" rel="noreferrer">NPM Official Documents: package.json</a></li><li><a href="https://semver.org/" target="_blank" rel="noreferrer">Semantic Versioning 2.0.0</a></li></ul><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import" target="_blank" rel="noreferrer">MDN: import</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p><a href="https://github.com/indexzero/http-server/blob/master/package.json" target="_blank" rel="noreferrer">http-server: package.json</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p></li></ol></section>`,31),n=[l];function r(c,p,d,i,u,m){return o(),s("div",null,n)}const j=e(t,[["render",r]]);export{f as __pageData,j as default};
